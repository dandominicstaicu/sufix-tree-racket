I am working on a racket project abut suffix-trees. I am re designing my project to lazy evaluation. I am using a new file collection.rkt where I define all the functions used instead of using just lists.

I will give you the request and the code written for now. then I will give you the old implementation of a function and will ask for the new one that does what is requested by the new requirement

requirement:


În etapa 3 ați putut observa că anumite aplicații (căutarea unui subșir în text, căutarea unui subșir de o anumită lungime care se repetă în text) nu necesită decât explorarea parțială a arborelui de sufixe asociat textului, prin urmare ar fi mai eficient ca acest arbore să fie construit “leneș”, pe măsură ce diverse porțiuni din el sunt necesare.

În acest scop, în etapa 4, veți modifica implementarea tipului ST astfel încât fiecare arbore (și, la rândul lor, toți subarborii aferenți) să fie nu o listă de ramuri, ci un flux de ramuri. Dacă aceasta ar fi singura modificare, singurele funcții care ar trebui redefinite ar fi constructorii și operatorii tipului ST (presupunând că ați respectat bariera de abstractizare a acestui tip).

Întrucât arborii sunt construiți pe baza tuturor sufixelor unui text, veți modifica de asemenea reprezentarea tuturor sufixelor unui text - ele vor fi reținute într-un flux, nu într-o listă cum s-a întâmplat până acum. Pentru că multe funcții din etapele anterioare primeau ca argumente sau întorceau liste de sufixe, va trebui să redefiniți, de asemenea, toate aceste funcții. Așa cum este explicat în scheletul de cod, această redefinire “în masă” putea fi evitată dacă am fi lucrat de la început cu conceptul de “colecție de sufixe”, în loc să presupunem că acestea vor fi grupate neapărat într-o listă. Una din cerințele etapei este să realizați acum acest re-design (implementând un nou tip de date Collection), și să observați cum el vă ajută să jonglați cu ușurință între reprezentările alternative pentru colecțiile de sufixe.

Este important să distingeți între colecțiile care devin fluxuri și cele care își păstrează vechea reprezentare:

    arborii devin fluxuri de ramuri
    ramurile rămân perechi etichetă-subarbore
    listele de sufixe/cuvinte devin fluxuri de sufixe/cuvinte
    sufixele/cuvintele/etichetele/textele rămân liste de caractere

Dintr-un anumit punct de vedere este o etapă ușoară, întrucât nu necesită implementarea unor funcții noi, ci doar ajustarea celor vechi (plus definirea tipului Collection). Dificultatea etapei constă în următoarele aspecte:

    aveți mai multă independență și responsabilitate în ceea ce privește designul programului
        vă veți defini singuri constructorii și operatorii utili pentru tipul Collection (fără să se spună în schelet fiecare funcție de care aveți nevoie)
        nu vom descrie din nou fiecare funcție care trebuie “ajustată”, întrucât comportamentul este același cu cel anterior, diferă eventual doar modul de reprezentare a datelor; voi înșivă trebuie să acționați conform specificației de mai sus și să înțelegeți când parametrii/rezultatul unei funcții au devenit, din liste, fluxuri
        sunteți responsabili pentru eficiența implementărilor, astfel încât, la rularea testelor, să vă încadrați în limita de timp impusă pe vmchecker; jumătate din teste folosesc un text lung, pentru care o implementare corectă cu fluxuri ar trebui să fie mult mai rapidă decât implementarea anterioară cu liste
    fără o înțelegere foarte bună a datelor cu care lucrați, nu veți ști când trebuie utilizate liste și funcții pe liste și când trebuie utilizate fluxuri și funcții pe fluxuri

Scopul etapei este consolidarea cunoștințelor legate de:

    fluxuri
    abstractizare (pe de o parte veți observa efectul respectării sau nerespectării barierei de abstractizare în etapele anterioare, pe de altă parte veți face un re-design care să abstractizeze și mai mult soluția, care va deveni astfel mai flexibilă)

În realitate, implementarea cu fluxuri ne ajută doar atunci când evităm astfel explorarea unei porțiuni semnificative din arbore. Pentru aplicații precum găsirea celui mai lung subșir comun a două texte, care necesită căutarea în întreg arborele, este mai eficientă reprezentarea cu liste, pentru că operațiile pe liste sunt mai rapide decât cele pe fluxuri. În săptămânile următoare, veți vedea că în limbajul Haskell nu avem dificultatea acestei alegeri, întrucât în acest limbaj toate listele sunt, de fapt, fluxuri. Sperăm că tema noastră v-a ajutat să înțelegeți mai bine anumite concepte din programare și v-a trezit interesul pentru ce va urma.



collection.rkt:
#lang racket

(provide (all-defined-out))

;; În acest fișier vă definiți constructorii și
;; operatorii tipului Collection.
;; În etapele anterioare, colecțiile erau de fapt
;; liste.
;; În definițiile de mai jos, veți considera că
;; o colecție este implementată ca flux.

; Întrucât stream-cons nu este o funcție obișnuită, 
; ci este definită ca o sintaxă specială, astfel
; încât ea să nu își evalueze argumentele înainte 
; de apel (comportament pe care ni-l dorim și pentru 
; collection-cons), nu putem folosi o definiție
; de tipul
;    (define collection-cons stream-cons)
; (genul acesta de definiție generează o eroare).
; Nici varianta
;    (define (collection-cons x xs) (stream-cons x xs))
; nu este o soluție, întrucât funcțiile definite de noi
; în Racket sunt funcții stricte, iar x și xs vor fi
; evaluate înainte de a intra în corpul funcției
; collection-cons și a descoperi că ele vor fi
; argumentele unui stream-cons.
; Modul de a defini collection-cons pentru a reproduce
; întocmai comportamentul lui stream-cons este:
(define-syntax-rule (collection-cons x xs) (stream-cons x xs))
; Obs: puteți schimba numele funcției, dacă nu vă
; place "collection-cons". Este o funcție folosită doar
; de voi în fișierul etapa4.rkt, nu de checker.


; TODO
; Scrieți în continuare restul definițiilor
; (care nu necesită o sintaxă specială).

;; Retrieves the first element of the collection
(define (collection-first col)
  (stream-first col))

;; Gets the rest of the collection, excluding the first element
(define (collection-rest col)
  (stream-rest col))

;; Checks if a collection is empty
(define (collection-empty? col)
  (stream-empty? col))

;; Applies the function `f` to each element of the collection, returning a new collection
(define (collection-map f col)
  (stream-map f col))

;; Filters the collection `col` using the predicate `pred`, returning a new collection
(define (collection-filter pred col)
  (stream-filter pred col))

(define (empty-collection)
  empty-stream)

(define (collection-drop col n)
  (if (or (collection-empty? col) (= n 0))
      col
      (collection-drop (collection-rest col) (- n 1))
      )
    )

(define (collection-append col1 col2)
  (define (append-helper s1 s2)
    (if (collection-empty? s1)
        s2
        (collection-cons (collection-first s1) (append-helper (collection-rest s1) s2))))
  (append-helper col1 col2))


#lang racket
(require "suffix-tree-stream.rkt")
(require "collection.rkt")

(provide (all-defined-out))

;; Vom prelua toate funcțiile din etapele 1-3 (exceptând
;; longest-common-substring, care nu beneficiază de 
;; reprezentarea ca flux întrucât parcurge tot arborele)
;; și le vom adapta la noua reprezentare a unui ST.
;;
;; Pentru că un ST este construit pornind de la o colecție
;; de sufixe și pentru că ne dorim să nu calculăm toate
;; sufixele decât dacă este nevoie, vom modifica toate
;; funcțiile care prelucrau liste de sufixe pentru a
;; prelucra fluxuri de sufixe.
;;
;; Obs: fără această modificare a listelor de sufixe în
;; fluxuri de sufixe, și presupunând că am manipulat
;; arborii de sufixe doar prin interfața definită în
;; fișierul suffix-tree (respectând astfel bariera de 
;; abstractizare), ar trebui să alterăm doar funcția 
;; suffixes->st care este practic un constructor pentru
;; tipul ST.
;; Din cauza transformării listelor de sufixe în fluxuri,
;; avem mult mai multe implementări de modificat.
;; Puteam evita acest lucru? Da, utilizând conceptul de
;; colecție de sufixe de la început (în loc să presupunem
;; că ele vor fi prelucrate ca liste). În loc de cons,
;; car, cdr, map, filter, etc. am fi folosit de fiecare
;; dată collection-cons, collection-first, ... etc. -
;; aceste funcții fiind definite într-o bibliotecă
;; inițială ca fiind echivalentele lor pe liste, și
;; redefinite ulterior în stream-cons, stream-first,
;; ... etc. Operatorii pe colecții de sufixe ar fi 
;; folosit, desigur, doar funcții de tip collection-.
;;
;; Am ales să nu procedăm astfel pentru că ar fi provocat
;; confuzie la momentul respectiv (când chiar operatorii
;; pe liste erau o noutate) și pentru a vă da ocazia să
;; faceți singuri acest "re-design".


; TODO
; Copiați din etapele anterioare implementările funcțiilor
; de mai jos și modificați-le astfel:
; - Toate funcțiile care lucrează cu liste de sufixe vor
;   lucra cu un nou tip de date Collection, ai cărui
;   constructori și operatori vor fi definiți de voi
;   în fișierul collection.rkt.
; - Pentru toate funcțiile, trebuie să vă asigurați că
;   este respectată bariera de abstractizare (atât în 
;   cazul tipului ST cât și în cazul tipului Collection).
; Obs: cu cât mai multe funcții rămân nemodificate, cu atât
; este mai bine (înseamnă că design-ul inițial a fost bun).

(define (find-longest-common-prefix w1 w2 common)
  (cond
    [(or (null? w1) (null? w2) (not (char=? (car w1) (car w2))))
     (list (reverse common) w1 w2)
     ]
    [else
     (find-longest-common-prefix (cdr w1) (cdr w2) (cons (car w1) common))
     ]
    )
  )

(define (longest-common-prefix w1 w2)
  (find-longest-common-prefix w1 w2 '())
  )



; am schimbat, în numele funcției, cuvântul list în
; cuvântul collection

(define (longest-common-prefix-of-collection words)
  (define (reduce-prefix words)
    (if (or (collection-empty? words) (collection-empty? (collection-rest words)))
        (collection-first words)
        (let* ((prefix-pair (longest-common-prefix (collection-first words) (collection-first (collection-rest words))))
               (common-prefix (car prefix-pair)))
          (reduce-prefix (collection-cons common-prefix (collection-rest (collection-rest words))))
          )
        )
    )
  (reduce-prefix words)
  )


(define (common-prefix-length lst1 lst2)
  (define (helper l1 l2 count)
    (if (or (null? l1)
            (null? l2)
            (not (char=? (car l1) (car l2)))) ; not match
        count ; return the count of matching characters
        (helper (cdr l1) (cdr l2) (+ 1 count))  ; continue with the rest of the lists
        )
    )

  (helper lst1 lst2 0)
  )

(define (match-pattern-with-label st pattern)
  (let ((branch (get-ch-branch st (car pattern)))) ; Assumes get-ch-branch can handle the stream/collection
    (if (not branch) ; If no branch starts with the pattern's first character
        (list #f '()) ; Pattern not found in the text
        (let* ((label (get-branch-label branch)) ; Assumes get-branch-label works with the stream/collection
               (subtree (get-branch-subtree branch)) ; Assumes get-branch-subtree works with stream/collection
               (common-prefix-length (common-prefix-length pattern label)))
          (cond
            ((equal? common-prefix-length (length pattern))
             #t) ; Fully matches the start of the label
            ((equal? common-prefix-length (length label))
             (if (= common-prefix-length 0)
                 (list #f '()) ; No common prefix
                 (list label (drop pattern common-prefix-length) subtree))) ; Partial match, need to search deeper
            (else
             (list #f (take pattern common-prefix-length)) ; Partial or no match, return common prefix
             )
            )
          )
        )
    )
  )



(define (st-has-pattern? st pattern)
  (define (search-in-subtree subtree pattern)
    (cond
      [(null? pattern) #t]  ; If the pattern is empty, it's found.
      [(collection-empty? subtree) #f]  ; If the subtree is empty, the pattern is not found.
      [else
       (let ((match-result (match-pattern-with-label subtree pattern)))
         (cond
           [(eq? match-result #t) #t]  ; Fully matched within a label.
           [(and (list? match-result) (eq? (first match-result) #f)) #f]  ; Does not match label.
           [(list? match-result)
            (search-in-subtree (third match-result) (second match-result))]  ; Partial match, continue in the subtree.
           [else #f] ; Case for completeness, though covered by the conditions above.
           )
         )
       ]
      )
    )  
  (search-in-subtree st pattern)
  )



(define (get-suffixes text)
  (define (suffixes-helper remaining-text)
    (if (null? remaining-text)
        (stream) ; Return an empty stream
        (stream-cons remaining-text
                     (suffixes-helper (cdr remaining-text))
                     )
        )
    )
  (suffixes-helper text)
  )


(define (get-ch-words words ch)
  (collection-filter (lambda (word)
                       (and (not (collection-empty? word)) ; check if a collection is empty
                            (char=? ch (collection-first word)) ; gets the first element of a collection
                            )
                            ) 
                     words
                     )
                     )

  ;                    (define (get-ch-words suffixes ch)
  ; (collection-filter (lambda (suffix)
  ;                      (char=? ch (collection-first suffix)))
  ;                    suffixes))



(define (ast-func suffixes)
  (let* ((first-suffix (collection-first suffixes)) ; Get the first suffix from the stream
         (label (list (collection-first first-suffix))) ; The label is a list containing the first character of the first suffix
         (new-suffixes (collection-map collection-rest suffixes))) ; Remove the first char from each suffix
    (cons label new-suffixes))) ; No need to convert, new-suffixes is already a stream


(define (stream-longest-common-prefix suffix-stream)
  (if (collection-empty? suffix-stream)
      '() ; Return an empty list if the stream is empty
      (let loop ((prefix (collection-first suffix-stream)) ; Initialize with the first suffix
                 (rest-suffixes (collection-rest suffix-stream)))
        (if (collection-empty? rest-suffixes)
            prefix ; Return the accumulated prefix if there are no more suffixes
            (let* ((next-suffix (collection-first rest-suffixes))
                   (new-prefix (car (longest-common-prefix prefix next-suffix)))) ; Compute LCP with the next suffix
              (loop new-prefix (collection-rest rest-suffixes))))))) ; Recurse with the new prefix and the rest of the suffixes


(define (cst-func suffixes)
  (let* ((lcp (stream-longest-common-prefix suffixes))  ; Assume this function is implemented for streams
         (label lcp)  ; The label is the LCP itself
         (new-suffixes (collection-map (lambda (suffix)
                                         (collection-drop suffix (length lcp))) ; Remove the LCP from each suffix
                                       suffixes)))
    (cons label new-suffixes)))  ; Return the pair of the label and new suffixes as streams































; (define (text->st labeling-func)
;   (lambda (text)
;     ;; Convert text to a collection and add the end marker
;     (let* ((text-with-end-marker (collection-append (list->collection text) (list->collection '(#\$)))))
;       ;; Generate suffixes as a collection
;       (let ((suffixes (get-suffixes text-with-end-marker)))
;         ;; Generate alphabet as a collection, including the end marker
;         (let ((alphabet (list->collection (sort (remove-duplicates (collection->list text-with-end-marker)) char<?))))
;           ;; Now, use the suffixes and alphabet collections to construct the suffix tree
;           (suffixes->st labeling-func suffixes alphabet))))))









; (define (suffixes->st labeling-func suffixes alphabet)
;   (if (stream-empty? alphabet)
;       empty-stream  ; If the alphabet stream is empty, return an empty stream
;       (let* ((ch (stream-first alphabet))  ; Take the first character of the alphabet
;              (ch-suffixes (get-ch-words suffixes ch))  ; Filter suffixes starting with ch, now using streams
;              (label-and-suffixes (and (not (stream-empty? ch-suffixes))
;                                       (labeling-func ch-suffixes)))  ; Apply labeling function lazily
;              (rest-alphabet (stream-rest alphabet)))  ; Prepare the rest of the alphabet for recursion
;         (if label-and-suffixes
;             (let ((label (car label-and-suffixes))
;                   (new-suffixes (cdr label-and-suffixes)))
;               (stream-cons (cons label (if (stream-empty? new-suffixes)
;                                            empty-stream
;                                            (suffixes->st labeling-func new-suffixes rest-alphabet)))
;                            (suffixes->st labeling-func suffixes rest-alphabet)))
;             (suffixes->st labeling-func suffixes rest-alphabet)))))  ; Continue with the rest of the alphabet if no label


; (define (suffixes->st labeling-func suffixes alphabet)
;   (if (stream-empty? alphabet)
;       empty-stream  ; No more characters in the alphabet to process.
;       (let ((ch (stream-first alphabet)))
;         (let ((ch-suffixes (get-ch-words suffixes ch)))
;           (if (stream-empty? ch-suffixes)
;               (suffixes->st labeling-func suffixes (stream-rest alphabet))  ; Skip character if no suffixes start with it.
;               (let* ((label-and-suffixes (labeling-func ch-suffixes))
;                      (label (car label-and-suffixes))
;                      (new-suffixes (cdr label-and-suffixes)))
;                 (stream-cons
;                  (cons label (if (stream-empty? new-suffixes) 
;                                  empty-stream 
;                                  (suffixes->st labeling-func new-suffixes (stream-rest alphabet))))  ; Process the rest of the alphabet with new suffixes.
;                  (suffixes->st labeling-func suffixes (stream-rest alphabet))))))))  ; Continue with the original suffixes for the rest of the alphabet.
; )

; (define (suffixes->st labeling-func suffixes alphabet)
;   (if (null? alphabet)
;       (empty-collection)  ; If the alphabet is empty, return an empty list
;       (collection-foldr (lambda (ch acc)  ; Use foldr to iterate over the alphabet and build the tree
;                (let* ((ch-suffixes (get-ch-words suffixes ch))  ; Get all suffixes starting with ch
;                       (label-and-suffixes (and (not (null? ch-suffixes))  ; Proceed if there are such suffixes
;                                              (labeling-func ch-suffixes))))  ; Apply labeling function
;                  (if label-and-suffixes  ; If labeling function returned a non-empty result
;                      (let* ((label (car label-and-suffixes))  ; Extract label
;                             (new-suffixes (cdr label-and-suffixes))  ; Extract new suffixes for subtree
;                             (subtree (if (null? new-suffixes)  ; If no new suffixes, subtree is empty
;                                          '()
;                                          (suffixes->st labeling-func new-suffixes alphabet))))  ; Recursive call for subtree
;                        (cons (cons label subtree) acc))  ; Add the branch to the accumulator
;                      acc)))  ; If no label-and-suffixes, just pass the accumulator unchanged
;              empty-collection  ; Initial accumulator is an empty list
;              alphabet)))  ; Fold over the alphabet

; (define (suffixes->st labeling-func suffixes-stream alphabet-stream)
;   ;; Helper function to create a branch for each character in the alphabet stream
;   (define (build-branches alphabet suffixes)
;     (if (stream-empty? alphabet)
;         (stream)  ; If no more characters in the alphabet, return an empty stream
;         (let ((ch (stream-first alphabet)))
;           (let ((ch-suffixes (stream-filter (lambda (suffix)  ; Filter suffixes starting with ch
;                                               (and (not (stream-empty? suffix))
;                                                    (char=? ch (stream-first suffix))))
;                                             suffixes)))
;             (if (stream-empty? ch-suffixes)  ; If no suffixes start with ch, skip it
;                 (build-branches (stream-rest alphabet) suffixes)
;                 (let* ((labeled (labeling-func ch-suffixes))  ; Apply labeling function
;                        (label (car labeled))
;                        (new-suffixes (cdr labeled))
;                        (subtree (if (stream-empty? new-suffixes)  ; If no new suffixes, subtree is empty
;                                     (stream)
;                                     (build-branches alphabet new-suffixes))))  ; Recurse to build subtree
;                   (stream-cons (cons label subtree)  ; Prepend this branch to the rest
;                                (build-branches (stream-rest alphabet) suffixes)))))))
;     )

;   (build-branches alphabet-stream suffixes-stream))